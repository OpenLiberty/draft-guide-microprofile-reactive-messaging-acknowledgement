//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging-acknowledgement
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging acknowledgement strategies to acknowledge messages.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['microprofile-reactive-messaging','microprofile-reactive-messaging-rest','reactive-messaging-sse','reactive-service-testing','microprofile-rest-client-async']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Acknowledging messages in Java microservices using MicroProfile Reactive Messaging
:page-seo-description: A getting started tutorial with examples on how to acknowledge messages in asynchronous Java microservices using different MicroProfile Reactive Messaging acknowledgement strategies.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Acknowledging messages using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to acknowledge messages using MicroProfile Reactive Messaging.

== What you'll learn

MicroProfile Reactive Messaging provides an easy way to handle messages in applications that process streams of events.
Messages are sent between decoupled microservices, and to ensure that no messages are lost in the event of a system failure,
reactive messaging systems utilize the concept of acknowledgement. Acknowledgement differentiates between a message that
has been delivered to the target service, and a message that has been processed and completed. Every message that gets sent
must be acknowledged. By differentiating the two, any messages that have been delivered but not acknowledged due to a
system failure can be sent again.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. You will explore the acknowledgement
strategies available using MicroProfile Reactive Messaging, and implement your own manual acknowledgement strategy.
You can learn more about how the reactive Java services used in this guide works by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.

[role='command']
include::{common-includes}/gitclone.adoc[]

== MicroProfile Reactive Messaging Acknowledgement Strategies

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

// file 1
SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

MicroProfile Reactive Messaging consists of four acknowledgement strategies: `NONE`, `PRE_PROCESSING`, `POST_PROCESSING`,
and `MANUAL`. Acknowledging messages is required in reactive applications. Messages are either acknowledged explicitly, or
implicitly by the MicroProfile Reactive Messaging implementation.

`@Acknowledgement` for the `@Incoming` messages is controlled by the `org.eclipse.microprofile.reactive.messaging.Acknowledgment`
annotation. If the `@Acknowledgement` annotation is not defined explicitly, the default acknowledgement strategy applies, and
depends on the method signature. Only methods that receive incoming messages and are annotated with `@Incoming` need to
acknowledge messages, methods that are only annotated with `@Outgoing` methods do not support acknowledgement.

Different defaults and supported acknowledgement for each supported signature could be found at the
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_message_acknowledgement[Messaging acknowledgement^]
table of the specification.

Here is a breakdown of the four acknowledgement strategies:

[cols="30, 100", options="header"]
|===
| *Strategy*        | *Description*
| NONE              | No acknowledgment will be performed. The `NONE` strategy may be used for the protocols that do not support message acknowledgment.
| PRE_PROCESSING    | The message is acknowledged before the method processes the received message. Methods that use the `PRE_PROCESSING` or `POST_PROCESSING` acknowledgement strategy rely on the MicroProfile Reactive Messaging implementation of said strategies.
| POST_PROCESSING   | If the acknowledgement strategy is set to `POST_PROCESSING`, the Reactive Messaging implementation will acknowledge the message depending on if the annotated method emits data:
|                   |   1. If the method emits data, the incoming message will be acknowledged once the outgoing message is acknowledged
|                   |   2. If the method does not emit data, the incoming message will be acknowledged once the method or processing completes
| MANUAL            | The source code is responsible for the acknowledgement, typically by using the `Message.ack()` method. `MANUAL` acknowledgement is useful for when the required acknowledgement can not be accomplished by any other existing Reactive Messaging implementation, and is often used when the incoming message should be acknowledged after the outgoing message is acknowledged.
|===

== Implementing the MANUAL acknowledgement strategy

The `inventory` service sends a system property request to the `system` service, but does not verify if the system
property is valid, therefore the verification is done in the `system` service. The message acknowledgement is handled
according to whether the system property request is valid or not.

Ensure that you are in the `start` directory.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The changes include implementing a `MANUAL` message acknowledgement strategy that fits the method processing requirements.
First, the method is annotated with the [hotspot=ackAnnotation file=1]`@Acknowledgment(Acknowledgment.Strategy.MANUAL)`
annotation, and therefore must manually acknowledge the message. Only incoming messages can be acknowledged, so the method
expects an incoming message. The method parameter is updated to receive a [hotspot=methodSignature file=1]`Message` of
type `String`, instead of just a string, to enable acknowledgement. Then, the message
[hotspot=propertyValue file=1]`payload` is extracted and checked for validity. There are two outcomes:

    1. If the system property is [hotspot=invalid file=1]`invalid`, the method [hotspot=propertyMessageAck file=1]`acknowledges`
        the incoming message and [hotspot=emptyReactiveStream file=1]`returns` an empty reactive stream. The processing is
        complete.
    2. If the system property is valid, the method creates a [hotspot=returnMessage file=1]`message` with
        the value of the requested system property, and sends it to the proper channel. The method will only acknowledge
        the incoming message when the sent message has been acknowledged.

== Waiting for a message to be acknowledged

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

The `inventory` service contains an endpoint that accepts `PUT` requests. When a `PUT` request is made to the `inventory`
service with a request body that contains a system property, the `inventory` service will send a message to the `system`
service, requesting the value of the system property. Currently, a `200` response code is returned without establishing
if the sent message has been acknowledged. Replace the `inventory` service to only return a `200` response once the outgoing
message has been acknowledged.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

Acknowledgement can only be done on incoming messages, so the [hotspot=sendPropertyName file=0]`sendPropertyName()` method
is updated to now return a [hotspot=SPMHeader file=0]`Message<String>` instead of just a `String`. The
[hotspot=updateSystemProperty file=0]`updateSystemProperty()` method now returns a
[hotspot=USPHeader file=0]`CompletionStage` wrapped around a Response. This allows for a response object
to be returned after the outgoing message is acknowledged. The outgoing message is created with the requested property
name as the payload, and an action to be executed once the message is acknowledged. The method creates a
[hotspot=CompletableFuture file=0]`CompletableFuture` variable that will return a [hotspot=returnResult file=0]`200`
response code once the variable is completed. The `CompletableFuture` variable is set to complete once the outgoing message
is [hotspot=acknowledgeAction file=0]`acknowledged`.

== Building and running the application

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

Wait for the services to become available. After the services are up and running, you can access the
application by making a GET request to the `/systems` endpoint of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "systemLoad":1.44
}
----

The `system` service sends messages to the `inventory` service every 15 seconds, the `inventory` service acknowledges each
incoming message after processing them, ensuring that no `system` message is lost.

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties.

For example :

The `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL will add the `os.name` system property for your system.

Make a `PUT` request to the service by using `curl`:

[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```

If the `curl` command is unavailable, then use https://www.getpostman.com/[Postman^]. Postman enables you
to make requests using a graphical interface. To make a request with Postman, enter `\http://localhost:9085/inventory/systems`
into the URL bar and change the request from `GET` to `PUT`. Go to the `Body` tab and enter the `os.name` value under
raw category. Click the blue `Send` button to make the request.

Behind the scenes, the `inventory` service sends a message containing the requested system property to the `system` service.
The `inventory` service then waits until the message has been acknowledged before sending a response back.

After sending the request you see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

The above response is confirmation that the sent request message has been acknowledged.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value in addition
to the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]