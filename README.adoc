//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging-acknowledgement
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging acknowledgement strategies to acknowledge messages.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['microprofile-reactive-messaging','microprofile-reactive-messaging-rest','reactive-messaging-sse','reactive-service-testing','microprofile-rest-client-async']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Acknowledging messages in Java microservices using MicroProfile Reactive Messaging
:page-seo-description: A getting started tutorial with examples on how to acknowledge messages in asynchronous Java microservices using different MicroProfile Reactive Messaging acknowledgement strategies.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Acknowledging messages using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to acknowledge messages using MicroProfile Reactive Messaging.

== What you'll learn

MicroProfile Reactive Messaging provides an easy way to handle messages in applications that process streams of events.
Messages are sent between decoupled microservices, and to ensure that no messages are lost in the event of a system failure,
reactive messaging systems utilize the concept of acknowledgement. Acknowledgement differentiates between a message that
has been delivered to the target service, and a message that has been processed and completed. Every message that gets sent
must be acknowledged. By differentiating the two, any messages that have been delivered but not acknowledged due to a
system failure can be sent again.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. You will explore the acknowledgement
strategies available using MicroProfile Reactive Messaging, and implement your own manual acknowledgement strategy.
You can learn more about how the reactive Java services used in this guide works by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.

[role='command']
include::{common-includes}/gitclone.adoc[]

== MicroProfile Reactive Messaging Acknowledgement Strategies

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

// file 1
SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

MicroProfile Reactive Messaging consists of four acknowledgement strategies: `NONE`, `PRE_PROCESSING`, `POST_PROCESSING`,
and `MANUAL`. Acknowledging messages is required in reactive applications. Messages are either acknowledged explicitly, or
implicitly by the MicroProfile Reactive Messaging implementation.

`@Acknowledgement` for the `@Incoming` messages is controlled by the `org.eclipse.microprofile.reactive.messaging.Acknowledgment`
annotation. If the `@Acknowledgement` annotation is not defined explicitly, the default acknowledgement strategy applies, and
depends on the method signature. Only methods that receive incoming messages and are annotated with `@Incoming` need to
acknowledge messages, methods that are only annotated with `@Outgoing` methods do not support acknowledgement.

Different defaults and supported acknowledgement for each supported signature could be found at the
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_message_acknowledgement[Messaging acknowledgement^]
table of the specification.

=== NONE Acknowledgement strategy

If the acknowledgement strategy is set to `NONE`, no acknowledgment will be performed. The `NONE` strategy may be used
for the protocols that do not support message acknowledgment. None of the methods in this guide have been configured to
use the `NONE` acknowledgement strategy.

=== PRE_PROCESSING Acknowledgement strategy

If the acknowledgement strategy is set to `PRE_PROCESSING`, the message is acknowledged before the method processes the
received message. Methods that use the `PRE_PROCESSING` or `POST_PROCESSING` acknowledgement strategy rely on the
MicroProfile Reactive Messaging implementation of said strategies. None of the methods in this guide have been configured
or defaults to using the `PRE_PROCESSING` acknowledgement strategy.

=== POST_PROCESSING Acknowledgement strategy

If the acknowledgement strategy is set to `POST_PROCESSING`, the Reactive Messaging implementation will acknowledge the
message depending on if the annotated method emits data:

    1. If the method emits data, the incoming message will be acknowledged once the outgoing message is acknowledged
    2. If the method does not emit data, the incoming message will be acknowledged once the method or processing completes

The `inventory` service contains two methods with the [hotspot=addSystemPropertyIncoming hotspot=systemLoadIncoming file=0]`@Incoming`
annotation, the [hotspot=updateStatus file=0]`updateStatus()` and the [hotspot=getPropertyMessage file=0]`getPropertyMessage()`
methods. Both methods have the same method signature, consuming a payload of an Object type, and returning void. The
https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html#_message_acknowledgement[Messaging acknowledgement^]
table specifies that the default acknowledgement strategies applied to methods of that signature is the `POST_PROCESSING`
strategy. Both methods use the incoming message to apply changes to the stored inventory of systems, and thus acts as a
message processor. In this example, the `POST_PROCESSING` strategy would be best, as the acknowledgement should ensure that
the message has been successfully processed. Since the method signature defaults to the `POST_PROCESSING` strategy,
there is no need to explicitly define the acknowledgement strategy, and is therefore omitted from the method.

=== MANUAL Acknowledgement strategy

If the acknowledgement strategy is set to `MANUAL`, the source code is responsible for the acknowledgement, typically by
using the `Message.ack()` method. `MANUAL` acknowledgement is useful for when the required acknowledgement can not be
accomplished by any other existing Reactive Messaging implementation, and is often used when the incoming message should
be acknowledged after the outgoing message is acknowledged.

The `inventory` service sends a system property request to the `system` service, but does not verify if the system
property is valid, therefore the verification is done in the `system` service. The message acknowledgement is handled
according to whether the system property request is valid or not.

Ensure that you are in the `start` directory.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The changes include implementing a `MANUAL` message acknowledgement strategy that fits the method processing requirements.
First, the method is annotated with the [hotspot=ackAnnotation file=1]`@Acknowledgment(Acknowledgment.Strategy.MANUAL)`
annotation, and therefore must manually acknowledge the message. Next, the method parameter is updated to a
[hotspot=methodSignature file=1]`Message` of type `String`, instead of just a string, as only messages can be acknowledged,
and therefore the method expects an incoming message. Then, the message [hotspot=propertyName file=1]`payload` is extracted
and checked for validity. There are two outcomes:

    1. If the system property is [hotspot=invalid file=1]`invalid`, the method [hotspot=propertyNameAck file=1]`acknowledges`
        the incoming message and [hotspot=emptyReactiveStream file=1]`returns` an empty reactive stream. The processing is
        complete.
    2. If the system property is valid, the method creates a new outgoing [hotspot=returnMessage file=1]`message` with
        the value of the requested system property, and sends it to the proper channel, and the method will only
        acknowledge the incoming message once the outgoing message has been acknowledged.

== Waiting for a message to be acknowledged

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

The `inventory` service contains an endpoint where, when a `PUT` request is submitted, will send a message to the `system`
service to provide the value of the requested system property. Currently, a `200` response code is returned without establishing
if the sent message has been acknowledged. Replace the `inventory` service to only return a `200` response once the outgoing
message has been acknowledged.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

(explain source code, pending on chat with Andrew)

== Building and running the application

// Include OS specific tabs
include::{common-includes}/os-tabs.adoc[]

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

Scripts are provided for you to easily package your application and build your images.

To build the application, use the provided script from the `start` directory:

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/packageApps.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\packageApps.bat
```
--

Next, run the following script to containerize the microservices. The script pulls the latest Open Liberty image and builds
the Docker images using the Dockerfiles in the `system` and `inventory` source directories:

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/buildImages.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\buildImages.bat
```
--

Next, run the following script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

Wait for the services to become available. After the services are up and running, you can access the
application by making a GET request to the `/systems` endpoint of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "systemLoad":1.44
}
----

The `system` service sends messages to the `inventory` service every 15 seconds, the `inventory` service acknowledges each
incoming message after processing them, ensuring that no `system` message is lost.

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties.

For example :

The `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL will add the `os.name` system property for your system.

Make a `PUT` request to the service by using `curl`:

[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```

If the `curl` command is unavailable, then use https://www.getpostman.com/[Postman^]. Postman enables you
to make requests using a graphical interface. To make a request with Postman, enter `\http://localhost:9085/inventory/systems`
into the URL bar and change the request from `GET` to `PUT`. Go to the `Body` tab and enter the `os.name` value under
raw category. Click the blue `Send` button to make the request.

Behind the scenes, the `inventory` service sends a message containing the requested system property to the `system` service.
The `inventory` service then waits until the message has been acknowledged before sending a response back.

After sending the request you see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

The above response is confirmation that the sent request message has been acknowledged.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value in addition
to the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]