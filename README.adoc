//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging-acknowledgement
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging acknowledgement strategies to acknowledge messages.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['microprofile-reactive-messaging','microprofile-reactive-messaging-rest','reactive-messaging-sse','reactive-service-testing','microprofile-rest-client-async']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Acknowledging messages in Java microservices using MicroProfile Reactive Messaging
:page-seo-description: A getting started tutorial with examples on how to acknowledge messages in asynchronous Java microservices using different MicroProfile Reactive Messaging acknowledgement strategies.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Acknowledging messages using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to acknowledge messages using MicroProfile Reactive Messaging.

== What you'll learn

Acknowledgements are a key concept in MicroProfile Reactive Messaging which ensure that messages are not lost in the
event of a system failure. Acknowledgement differentiates between a message that
has been delivered to the target service, and a message that has been processed and completed. Every message that gets sent
must be acknowledged. By differentiating the two, any messages that have been delivered but not acknowledged due to a
system failure can be sent again.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. You will explore the acknowledgement
strategies available using MicroProfile Reactive Messaging, and implement your own manual acknowledgement strategy.
You can learn more about how the reactive Java services used in this guide work by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.

[role='command']
include::{common-includes}/gitclone.adoc[]

== MicroProfile Reactive Messaging Acknowledgement Strategies

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

// file 1
SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

Acknowledging messages is required in reactive applications. Messages are either acknowledged explicitly, or
implicitly by the MicroProfile Reactive Messaging implementation. Acknowledgement for the incoming messages is controlled
by the `@Acknowledgment` annotation in the MicroProfile Reactive Messaging specification. If the `@Acknowledgement`
annotation is not defined explicitly, the default acknowledgement strategy applies, and depends on the method signature.
Only methods that receive incoming messages and are annotated with `@Incoming` need to acknowledge messages, methods
that are only annotated with `@Outgoing` methods do not support acknowledgement.

Different strategy defaults and supported acknowledgement for each supported signature could be found at the
https://openliberty.io/docs/latest/reference/javadoc/microprofile-3.3-javadoc.html#package=org/eclipse/microprofile/reactive/messaging/package-frame.html&class=overview-summary.html[MicroProfile Reactive Messaging Javadoc^]
table of the specification.

By default, all of the methods that require acknowledging messages are assigned the `POST_PROCESSING` strategy. If the
acknowledgement strategy is set to POST_PROCESSING, the Reactive Messaging implementation will acknowledge the message
depending on if the annotated method emits data:

    1. If the method emits data, the incoming message will be acknowledged once the outgoing message is acknowledged.
    2. If the method does not emit data, the incoming message will be acknowledged once the method or processing completes.

The acknowledgement strategy to use for a method depends on the use case of said method. The `system` service contains
a method which defaults to the `POST_PROCESSING` strategy. This is insufficient and does not produce the desired behaviour.

The `system` service contains the [hotspot=sendProperty file=1]`sendProperty` method which receives property requests
from the `inventory` service. For each property request, if the property being requested is valid then it produces a
property response with the value of the property. However, if the requested property doesn't exist, the request is ignored
and no property response is produced.

There is a key difference here, in the case where a property response is produced, the request is not finished processing
until the response has been sent and safely stored, and it is only then that the incoming message should be acknowledged.
However, in the case where the property requested doesn't exist, the method has already finished processing the request
message so the message needs to be acknowledged immediately.

This situation where a message either needs to be acknowledged immediately or some time later is one of the cases where
the `MANUAL` acknowledgement strategy would be beneficial.

== Implementing the MANUAL acknowledgement strategy

Ensure that you are in the `start` directory.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The changes include implementing a `MANUAL` message acknowledgement strategy that fits the method processing requirements.
First, the method is annotated with the [hotspot=ackAnnotation file=1]`@Acknowledgment(Acknowledgment.Strategy.MANUAL)`
annotation, and therefore must manually acknowledge the message. Only incoming messages can be acknowledged, so the method
expects an incoming message. The method parameter is updated to receive a [hotspot=methodSignature file=1]`Message` of
type `String`, instead of just a string, to enable acknowledgement. Then, the message
[hotspot=propertyValue file=1]`payload` is extracted and checked for validity. There are two outcomes:

    1. If the system property is [hotspot=invalid file=1]`invalid`, the method [hotspot=propertyMessageAck file=1]`acknowledges`
        the incoming message and [hotspot=emptyReactiveStream file=1]`returns` an empty reactive stream. The processing is
        complete.
    2. If the system property is valid, the method creates a [hotspot=returnMessage file=1]`message` with
        the value of the requested system property, and sends it to the proper channel. The method will only acknowledge
        the incoming message when the sent message has been acknowledged.

== Waiting for a message to be acknowledged

The `inventory` service contains an endpoint that accepts `PUT` requests. When a `PUT` request is made to the `inventory`
service with a request body that contains a system property, the `inventory` service will send a message to the `system`
service, requesting the value of the system property. Currently, a `200` response code is returned without establishing
if the sent message has been acknowledged. Replace the `inventory` service to only return a `200` response once the outgoing
message has been acknowledged.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

Acknowledgement can only be done on incoming messages, so the [hotspot=sendPropertyName file=0]`sendPropertyName()` method
is updated to now return a [hotspot=SPMHeader file=0]`Message<String>` instead of just a `String`. The
[hotspot=updateSystemProperty file=0]`updateSystemProperty()` method now returns a
[hotspot=USPHeader file=0]`CompletionStage` wrapped around a Response. This allows for a response object
to be returned after the outgoing message is acknowledged. The outgoing message is created with the requested property
name as the payload, and an action to be executed once the message is acknowledged. The method creates a
[hotspot=CompletableFuture file=0]`CompletableFuture` variable that will return a [hotspot=returnResult file=0]`200`
response code once the variable is completed. The `CompletableFuture` variable is set to complete once the outgoing message
is [hotspot=acknowledgeAction file=0]`acknowledged`.

== Building and running the application

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

After the application is up and running, you can access the application by making a GET request to the `/systems` endpoint
of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "systemLoad":1.44
}
----

The `system` service sends messages to the `inventory` service every 15 seconds, the `inventory` service acknowledges each
incoming message after processing them, ensuring that no `system` message is lost.

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties. For example, run the following `curl` command:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```
--

[.tab_content.windows_section]
--
If `curl` is unavailable on your computer, use another client such as https://www.getpostman.com/[Postman^],
which allows requests to be made with a graphical interface.
--

In this example, the `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL adds the `os.name` system property for your system. The `inventory` service sends a message containing the requested
system property to the `system` service. The `inventory` service then waits until the message has been acknowledged
before sending a response back.

You see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

The above response is confirmation that the sent request message has been acknowledged.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value is now
included with the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]