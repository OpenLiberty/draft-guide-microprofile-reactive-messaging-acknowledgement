//  Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microprofile-reactive-messaging-acknowledgement
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2020-04-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Reactive Messaging acknowledgement strategies to acknowledge messages.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE', 'Microservices']
:page-related-guides: ['microprofile-reactive-messaging','microprofile-reactive-messaging-rest','reactive-messaging-sse','reactive-service-testing','microprofile-rest-client-async']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Acknowledging messages in Java microservices using MicroProfile Reactive Messaging
:page-seo-description: A getting started tutorial with examples on how to acknowledge messages in asynchronous Java microservices using different MicroProfile Reactive Messaging acknowledgement strategies.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Acknowledging messages using MicroProfile Reactive Messaging

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to acknowledge messages using MicroProfile Reactive Messaging.

== What you'll learn

MicroProfile Reactive Messaging provides a reliable way to handle messages in reactive applications, ensuring that these
messages are not lost, by acknowledging messages that have been delivered to the target
server. Every message that gets sent out must be acknowledged. This ensures that any messages that have been delivered
to the target service but not acknowledged (e.g. due to a system failure) can be sent again.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. The following diagram showcases the
application used in this guide:

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory, align="center"]

You will explore the acknowledgement
strategies available using MicroProfile Reactive Messaging, and implement your own manual acknowledgement strategy.
You can learn more about how the reactive Java services used in this guide work by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.

== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.

[role='command']
include::{common-includes}/gitclone.adoc[]

== Choosing an acknowledgement strategy

// file 0
start/SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

Acknowledging messages is required in reactive applications. Messages are either acknowledged explicitly, or
implicitly by MicroProfile Reactive Messaging (MPRM). Acknowledgement for the incoming messages is controlled
by the `@Acknowledgment` annotation in MPRM. If the `@Acknowledgement`
annotation is not defined explicitly, the default acknowledgement strategy applies, and depends on the method signature.
Only methods that receive incoming messages and are annotated with `@Incoming` need to acknowledge messages, methods
that are only annotated with `@Outgoing` do not need to worry about acknowledging messages since no messages are being
received, and the MPRM acknowledgement requirement is that every message _received_ is acknowledged.

Based on the method signature, all of the methods in this application that require acknowledging messages are assigned
the `POST_PROCESSING` strategy by default. If the
acknowledgement strategy is set to `POST_PROCESSING`, MPRM acknowledges the message
depending on if the annotated method emits data:

    - If the method emits data, the incoming message is acknowledged once the outgoing message is acknowledged.
    - If the method does not emit data, the incoming message is acknowledged once the method or processing completes.

The acknowledgement strategy to use for a method depends on the use case of the method. The `system` service contains
a method which defaults to the `POST_PROCESSING` strategy. This is insufficient and does not produce the desired behaviour.

The `system` service contains the [hotspot=sendProperty file=0]`sendProperty` method which receives property requests
from the `inventory` service. For each property request, if the property being requested is valid then it
[hotspot=validReturn file=0]`returns` a property response with the value of the property. However, if the requested
property [hotspot=null file=0]`doesn't exist`, the request is ignored and no property response is
[hotspot=returnNull file=0]`returned`.

There is a key difference here, in the case where a property response is produced, the request is not finished processing
until the response has been sent and safely stored, and it is only then that the incoming message should be acknowledged.
However, in the case where the property requested doesn't exist, the method has already finished processing the request
message so the message needs to be acknowledged immediately.

This situation where a message either needs to be acknowledged immediately or some time later is one of the cases where
the `MANUAL` acknowledgement strategy would be beneficial.

== Implementing the MANUAL acknowledgement strategy

// file 0
finish/SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

Ensure that you are in the `start` directory.

Update the `SystemService` class to use the `MANUAL` acknowledgement strategy, which fits the method processing
requirements better than the default `POST_PROCESSING` strategy.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The [hotspot=sendProperty file=0]`sendProperty` method is annotated with the
[hotspot=ackAnnotation file=0]`@Acknowledgment(Acknowledgment.Strategy.MANUAL)`
annotation, and therefore must manually acknowledge the message. Only incoming messages can be acknowledged, so the method
expects an incoming message. The method parameter is updated to receive a [hotspot=methodSignature file=0]`Message` of
type `String`, instead of just a string, to enable acknowledgement. Then, the message
[hotspot=propertyValue file=0]`payload` is extracted and checked for validity. There are two outcomes:

    - If the system property is [hotspot=invalid file=0]`invalid`, the method [hotspot=propertyMessageAck file=0]`acknowledges`
        the incoming message and [hotspot=emptyReactiveStream file=0]`returns` an empty reactive stream. The processing is
        complete.
    - If the system property is valid, the method creates a [hotspot=returnMessage file=0]`message` with
        the value of the requested system property, and sends it to the proper channel. The method will only acknowledge
        the incoming message when the sent message has been acknowledged.

== Waiting for a message to be acknowledged

// file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

The `inventory` service contains an endpoint that accepts `PUT` requests. When a `PUT` request is made to the `inventory`
service with a request body that contains a system property, the `inventory` service sends a message to the `system`
service, requesting the value of the system property. Currently, a `200` response code is returned without establishing
if the sent message has been acknowledged. Replace the `inventory` service to only return a `200` response once the outgoing
message has been acknowledged.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

Acknowledgement can only be done on incoming messages, so the [hotspot=sendPropertyName file=0]`sendPropertyName()` method
is updated to now return a [hotspot=SPMHeader file=0]`Message<String>` instead of just a `String`. The
[hotspot=updateSystemProperty file=0]`updateSystemProperty()` method now returns a
[hotspot=USPHeader file=0]`CompletionStage` wrapped around a Response. This allows for a response object
to be returned after the outgoing message is acknowledged. The outgoing message is created with the requested property
name as the payload, and an action to be executed once the message is acknowledged. The method creates a
[hotspot=CompletableFuture file=0]`CompletableFuture` variable that returns a [hotspot=returnResult file=0]`200`
response code once the variable is completed. The `CompletableFuture` variable is set to complete once the outgoing message
is [hotspot=acknowledgeAction file=0]`acknowledged`.

== Building and running the application

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

After the application is up and running, you can access the application by making a GET request to the `/systems` endpoint
of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "systemLoad":1.44
}
----

The `system` service sends messages to the `inventory` service every 15 seconds, the `inventory` service acknowledges each
incoming message after processing them, ensuring that no `system` message is lost.

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties. For example, run the following `curl` command:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```
--

[.tab_content.windows_section]
--
If `curl` is unavailable on your computer, use another client such as https://www.getpostman.com/[Postman^],
which allows requests to be made with a graphical interface.
--

In this example, the `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL adds the `os.name` system property for your system. The `inventory` service sends a message containing the requested
system property to the `system` service. The `inventory` service then waits until the message has been acknowledged
before sending a response back.

You see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

The above response is confirmation that the sent request message has been acknowledged.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value is now
included with the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just developed an application using MicroProfile Reactive Messaging, Open Liberty and Kakfa.

== Related Links

Learn more about MicroProfile.

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.html[View the MicroProfile Reactive Messaging Specification^]

https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/apidocs/[View the MicroProfile Reactive Messaging Javadoc^]

https://openliberty.io/docs/ref/microprofile[View the MicroProfile API^]

include::{common-includes}/attribution.adoc[subs="attributes"]